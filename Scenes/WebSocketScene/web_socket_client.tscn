[gd_scene load_steps=2 format=3 uid="uid://d1r6rix6an4i5"]

[sub_resource type="GDScript" id="GDScript_au63s"]
script/source = "extends Node

class_name WebSocketClient

var last_state = WebSocketPeer.STATE_CLOSED

signal connected_to_server()
signal connection_closed()
signal message_received(message: Variant)

func poll() -> void:
	if Global.socketCLT.get_ready_state() != Global.socketCLT.STATE_CLOSED:
		Global.socketCLT.poll()
	
	var state = Global.socketCLT.get_ready_state()
	
	if last_state != state:
		last_state = state
		
		if  state == Global.socketCLT.STATE_OPEN:
			connected_to_server.emit()
		elif state == Global.socketCLT.STATE_CLOSED:
			connection_closed.emit()
	
	while Global.socketCLT.get_ready_state() == Global.socketCLT.STATE_OPEN and Global.socketCLT.get_available_packet_count():
		message_received.emit(get_message())

func get_message() -> Variant:
	if Global.socketCLT.get_available_packet_count() < 1:
		return null
	
	var packet = Global.socketCLT.get_packet()
	if Global.socketCLT.was_string_packet():
		return packet.get_string_from_utf8()
	
	return bytes_to_var(packet)

func send(message) -> int:
	if typeof(message) == TYPE_STRING:
		return Global.socketCLT.send_text(message)
	
	return Global.socketCLT.send(var_to_bytes(message))

func connect_to_url(url) -> int:
	var error = Global.socketCLT.connect_to_url(url)
	if error != OK:
		return error
	last_state = Global.socketCLT.get_ready_state()
	return OK

func close(code := 1000, reason := \"\") -> void:
	Global.socketCLT.close(code, reason)
	last_state = Global.socketCLT.get_ready_state()
	
func clear() -> void:
	print(\"clear\")

func get_socket() -> WebSocketPeer:
	return Global.socketCLT
	
func _process(delta):
	poll() 
"

[node name="WebSocketClient" type="Node"]
script = SubResource("GDScript_au63s")
